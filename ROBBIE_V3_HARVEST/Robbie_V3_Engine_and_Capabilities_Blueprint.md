Robbie V3 Assistant – Project Scope & Features
Overview & Vision

Robbie V3 is an AI-driven personal and team productivity assistant that integrates with your communication, calendar, and CRM tools to save time and streamline workflows. It acts as a unified digital teammate that connects emails, chats, meetings, and tasks into a single intelligent system, surfacing what matters and automating routine actions. The design follows key principles: every interface should deliver value within 10 seconds of a glance, with an exception-based UI that highlights only what needs attention. The system favors simplicity and opinionated defaults over complex configuration, providing just-in-time insights while suppressing noise. Robbie maintains situational awareness – the assistant’s header display shows context like the user’s current mood rationale, time, weather, next meeting, and any critical alerts. Under the hood, PostgreSQL (with a vector index) serves as the single source of truth for data, and all actions are mediated through a secure backend – no provider keys or sensitive data ever live in the front-end. Human judgment is respected with human-in-the-loop approvals for major decisions (e.g. big discounts, deal reassignments), and multiple safety guardrails are in place to prevent over-communication or mistakes. Overall, Robbie V3’s north star is to maximize focus on deep work by handling the busywork: it routes leads, drafts emails, schedules meetings, and summarizes information proactively so the user can focus on high-value work.

Project Scope & Phased Rollout

Initially, Robbie V3 will be deployed for personal use by a single user (founder level), acting as a personal executive assistant. In this Phase 1, it will connect only to the user’s own accounts (email, calendar, etc.) and provide private insights and automation. The scope will then expand to a limited team pilot (Phase 2) where Robbie provides reporting and assistance across a small team – for example, sharing pipeline summaries or task digests with the team, and coordinating team meetings. Finally, in Phase 3, the assistant will support interactive Slack queries from the team, effectively becoming a Slack bot that team members can query for information or delegate tasks to. By the end of these phases, Robbie will transition from a personal assistant to a team AI copilot: initially delivering value to one user, then reporting on team status, and eventually handling questions and commands from multiple users via Slack. Each phase will retain a strong emphasis on security and privacy (e.g. ensuring team members only see data they are permitted to), and new features (like the Slack Q&A interface) will be feature-flagged until ready for broader use.

System Architecture

Frontend: Robbie’s front-end is a responsive React single-page application (SPA). This provides an interactive dashboard and chat interface where the user can converse with Robbie and view various assistant “panels” (Inbox, Notes, Pipeline, etc. described below). Real-time updates (such as new incoming messages or task changes) are delivered via a WebSocket channel (proxied through Nginx on /ws), so the UI updates instantly without full refreshes.

Backend: The backend consists of a Node.js Express API (running under PM2 in cluster mode) that exposes RESTful endpoints and webhooks for the front-end to call. This API server handles authentication, serves data from the database, and orchestrates complex actions via an automation controller. All heavy automation logic is offloaded to a dedicated Master Control Program (MCP) implemented with n8n workflows. The Node API acts as a gateway: when the user triggers an action (e.g. “send email” or “create task”), the API forwards the request to n8n via a webhook (/n8n/webhook/mcp/...) along with context, and n8n executes the appropriate workflow. This MCP-first architecture centralizes integration logic – the n8n workflows have the credentials for external services and handle calling out to Gmail, Slack, HubSpot, etc., meaning the front-end and API never directly store long-lived provider tokens. The data layer is a PostgreSQL 15 database (with the pgvector extension for AI embeddings) and a Redis cache. PostgreSQL holds all persistent data – CRM records, communications, tasks, notes, etc. – partitioned into logical schemas for auth, app, and AI features. Redis is used for transient data like job queues, rate limiting, and caching of tokens/status. The database schema is designed for multi-tenancy (each record links to an org_id to support multiple organizations or users in the future) and has been carefully indexed for performance (including HNSW indexes for vector similarity search). The AI model components run on an integrated basis: Robbie can call OpenAI or other large language model APIs for advanced reasoning, but it also includes a local LLM model (served via Ollama, e.g. a Llama2 8B model as a fallback) to ensure some functionality even without external API access. Model usage is tracked for cost and performance optimization (logged to an ai.model_usage table).

Infrastructure: Robbie V3 is deployed on an Elestio VM (Ubuntu 24.04 LTS) which is security-hardened and locked down. Only essential access points are enabled: HTTPS for the web app, SSH on a custom port for maintenance, and webhook endpoints for n8n – everything else is firewalled. The deployment script sets up Nginx with SSL (Let’s Encrypt via Certbot), the PostgreSQL database, Redis, the Node API, n8n, and Ollama, plus utilities like Fail2Ban and UFW for security. Processes are managed as systemd services or PM2 processes, with logs aggregated to files under /opt/robbie-v3/logs for troubleshooting. The system is configured to start on boot and recover gracefully: the install includes systemd health checks and auto-restart policies for each service. For example, after deployment, unattended upgrades are enabled to keep the OS patched. All secrets (database passwords, API keys for integrations, etc.) are stored in a root-only environment file (/etc/app/env with 600 permissions) and injected into services at start. This ensures no credentials are exposed in code repositories or client-side code.

Security & Authentication

Robbie V3 includes a robust Authentication & Security module to protect user data. Users (in the app’s app.users table) can log in with email and password, which are stored as Argon2id secure hashes (with parameters tuned for ~200ms hash time to resist cracking). The auth system implements 3-strike lockouts (after a few failed login attempts, the account or IP is temporarily locked) and progressive CAPTCHA challenges for suspicious activity. All login and account events are logged to an audit trail (auth.auth_events) for monitoring. Sessions use short-lived JWT access tokens and longer-lived refresh tokens stored in HttpOnly, Secure cookies – this allows the front-end to stay logged in without constantly re-entering credentials, but limits the impact of any token leak. A refresh token rotation mechanism is in place (refresh tokens are one-time use and get renewed on each login), and session records in the DB allow server-side revocation. The system also supports OAuth2 login via external providers (Google, Slack, HubSpot, LinkedIn) as needed, so users can authenticate with those accounts instead of a password (or link them after password auth).

For accessing external integrations, Robbie uses user-delegated OAuth 2.0 where possible. During setup, the user will grant Robbie access to their Gmail, Calendar, Slack, etc., and these OAuth tokens (or API keys for services like Fireflies or OpenPhone that use token auth) are stored in the secure backend (never in local storage or exposed to the UI). All outbound requests to external APIs go through the MCP workflows which include standardized error handling: exponential backoff on rate limits or server errors, and honoring any Retry-After headers. Idempotency keys are used for any create/update actions to avoid duplicates if a request is retried. The API and MCP share a uniform response envelope structure ({ ok, data, error, trace_id }) for consistent error handling and debugging.

Access Control: Robbie’s data model has role-based permissions – each user is assigned a role (e.g. Admin, Manager, Rep) which can restrict what they can see or do. In the initial personal-use phase, this is less critical (only one user, who is effectively Admin), but as team features roll out, certain actions (like modifying global settings or viewing another user’s tasks) will be limited to Admins. Also, by design, each organization’s data is siloed by org_id in the database – so when the system expands to multiple organizations or external teams, one org cannot access another org’s data. All integration actions performed by Robbie on behalf of a user are either user-scoped (e.g. using that user’s OAuth token to send an email) or are read-only for gathering intelligence. There are no default broad sends or changes without user approval except where explicitly allowed by policy and role (e.g. the system might auto-assign a lead to a rep, but it will not send a message to a client without a human review unless it falls in allowed parameters). These guardrails and approval flows are discussed more below. Finally, the entire system adheres to secure development best practices: parameters are validated server-side, SQL queries use parameterization (or an ORM) to prevent injection, and the web app is served over HTTPS with secure cookies.

Integrations & Data Ingestion

One of Robbie’s core strengths is its deep integration with the user’s existing tools and data. Out-of-the-box, Robbie V3 will connect to: Gmail (reading and sending emails), Slack (reading channels and DMs, posting messages as a bot), OpenPhone (to log calls and texts), HubSpot CRM (for contacts, companies, deals, and pipeline updates), Google Calendar (events and availability), Google Drive (documents and files), Fireflies.ai (meeting transcripts), and more. These integrations are facilitated by the n8n MCP workflows – for example, there are n8n services for HubSpot (hubspot.upsert_contact, hubspot.upsert_deal, etc. updating the Postgres CRM tables), for Gmail (gmail.search_messages, gmail.send), for Slack (slack.post_message, slack.upload_file), for Calendar (calendars.events_list, calendars.create_event), and even for pulling Fireflies transcripts via their GraphQL API (fireflies.get_transcript). Each integration runs through a standardized API callable interface, which handles authentication (using stored OAuth tokens or API keys), throttling, and error retries uniformly.

Historical Data Backfill: Upon connecting a new data source, Robbie can perform an automatic historical backfill to import past data (emails, messages, events, etc.) into its knowledge base. This ensures the assistant has context from day one, not just new data going forward. The backfill process is carefully designed to be safe for large data volumes: it uses an ingestion_state checkpoint table to track progress, and employs windowed, rate-limited fetching so as not to overwhelm either the source API or the local system. Connectors run in two modes – a one-time bulk backfill of all historical data, and an optional follow mode that continuously pulls new data (e.g. check every few minutes for new emails). For example, the Gmail backfill worker will fetch messages in batches (using Gmail’s RFC822 export for full email bodies) partitioned by date ranges to avoid deep pagination issues. The calendar backfill will list all events since a certain date and import them into an internal calendar_events table. The system can also import the user’s contacts (via Google People API for Google contacts, or directly from HubSpot CRM) to build a unified contacts list. All these historical imports run as background services (managed by systemd on the VM) and log their progress to files (e.g. /var/log/app/backfill/gmail.log). After backfilling, the services either terminate (one-shot mode) or switch to streaming mode for new changes (for instance, using Gmail’s push notifications or Slack’s event API to catch new items).

All data ingested from external sources is normalized into the PostgreSQL database. Email messages, for instance, are stored with fields like subject, sender, recipients, timestamps, and a snippet/preview, in a messages table, with separate tables for email threads to group conversations. Slack messages and other chat interactions similarly land in an app.interactions table or specialized tables with links to contacts or deals when relevant. Calendar events are stored with their details (start/end time, attendees, etc.) in an app.calendar_events table. By consolidating all this data internally, Robbie can cross-reference information (linking a Slack message to the corresponding contact and deal, for example) and run analytics on it. For efficiency, large payloads (like email bodies or attachments) may be stored in an object storage or NAS rather than directly in the DB – the system is designed to store file metadata and a pointer (URL or path) to the actual file content. (This is part of the NAS integration plan, ensuring that as the system scales, email attachments or audio recordings from calls can be stored in a dedicated file storage service accessible to Robbie, rather than bloat the database).

Unified Interaction Log: As data flows in from all these sources, Robbie maintains a unified log of interactions that ties everything together. Every email, Slack chat, calendar meeting, call, etc., is represented as an interaction in the app.interactions table, with a type (GMAIL, SLACK, MEETING, CALL, etc.), a timestamp, a snippet or summary, and pointers to related records (such as which contact or deal it pertains to). Whenever possible, Robbie links interactions by context – for example, if an email thread and a Slack conversation are both with John Doe at Acme Corp, they will be mapped to the same contact and deal, allowing Robbie to see them as part of one ongoing “episode”. The platform’s Intent & Context Crew (described later) also tags interactions that are part of the same continuous discussion, even across channels, by using semantic similarity (vector search) and time proximity. This means when Robbie is answering a question or compiling a summary, it can pull in related info across email, chat, and meetings seamlessly as one thread of context.

AI Memory & Reasoning Engine

Robbie V3 combines advanced vector-based memory with rule-based process automation to drive its intelligence.

Memory System: The assistant implements a two-tier memory: long-term semantic memory and short-term working memory. All significant content that Robbie encounters – emails, chat messages, meeting transcript highlights, “sticky notes” (important notes or decisions) – are embedded as high-dimensional vectors (1536-dimension embeddings) and stored in a pgvector index in the database. This semantic index allows Robbie to retrieve information by meaning, not just exact keywords. For example, if the user later asks, “What did I promise the client last month?”, Robbie can do a vector similarity search to find the snippet of an email or call transcript where a promise was made, even if the wording is different. This long-term memory acts like an extension of the user’s brain, retaining important facts and decisions indefinitely (with old interactions distilled into summary form). Meanwhile, short-term memory holds recent interactions in an ephemeral buffer. Robbie uses a sliding context window with automatic summarization: as a conversation (email thread, Slack chat, etc.) grows, older messages are summarized into concise notes to free up space for new messages. These summaries themselves get stored as knowledge snippets (“sticky notes”) in the knowledge base. The combination ensures that even if an interaction goes beyond the AI model’s immediate token limit, the important points aren’t lost – they’ve been captured in summarized form and can be recalled later (an approach akin to a ConversationSummaryBuffer to manage context limits). Robbie’s memory also works across channels: using the unified interaction log mentioned above, it can join context from an email and a meeting and a Slack chat if they involve the same project or person. This episodic memory linking means the assistant understands the full story, not siloed streams.

To prevent memory overload, Robbie employs progressive summarization and retention policies. Fresh data is ingested verbatim, but as it ages, the system automatically creates higher-level summaries and can trim away very granular detail. For instance, a raw meeting transcript might be kept in full for 1-2 weeks, but after that, only the key decisions and action items (which were extracted and saved as notes) are kept in active memory, with the full transcript archived externally. The vector store can hold multiple layers of summary (fine detail vs. high-level) with timestamps, enabling time-scoped recall if needed. By default, we may keep the last ~6 months of detailed interactions online, and older data only as summarized vectors. This ensures the working set stays relevant and performance remains high, without truly forgetting anything important (since the essence lives on in the vector archive). Whenever Robbie crafts a response or needs context beyond the recent conversation, it performs a vector retrieval query against the memory index, filtered by relevant entities (e.g. if answering about a deal, it will filter by that deal’s ID to get only related facts). This provides the language model with a curated memory of past events to ground its answers, giving responses that are both up-to-date and personalized with historical context.

Adaptive Decision Engine: Beyond reactive Q&A, Robbie V3 is built to proactively handle common workflows through specialized AI services. These are essentially AI-powered playbooks for high-value tasks in sales and productivity, each with trigger conditions, business rules, AI decision-making, and feedback loops to improve over time. The design prioritizes five key processes (with more to be added later). The initial set includes:

Lead Assignment & Capacity-Based Routing: Automatically route new leads or deals to the appropriate owner on the team, based on predefined criteria and real-time workload. For example, a new Contact coming from the website or a deal created in HubSpot triggers the Assignment Crew. It checks the lead’s attributes (company size, potential deal value) and categorizes it into A/B/C tiers per policy. An A category lead (e.g. enterprise >$500M or deal >$100K) is assigned to senior owners (like the founder/CEO plus a top rep), B mid-market leads go to mid-level sales, and C small leads to junior reps. This policy is stored in a table (app.assignment_policies) and can be easily adjusted. The crew then checks each proposed owner’s current workload using a live capacity heatmap (e.g. a materialized view v_team_workload tracking how many active deals, tasks, and interactions each person has). If the first-choice owner is over 120% of their capacity threshold, the system will auto-reroute the lead to the next person and log an override reason. A database trigger assign_deal_owner() serves as a safety net to ensure no deal remains unassigned. The chosen owner is updated in HubSpot and in the internal database, and a notification (email/Slack) is sent to that rep saying “You’ve been assigned a new deal”. This workflow balances workload so no single rep is overwhelmed and leads don’t fall through the cracks. All assignment decisions (and any overrides) are logged for transparency, and over time the policy can even adapt – e.g. if one team member is consistently overloaded, the rules can shift to distribute more leads elsewhere. Robbie’s weekly/team digest includes a “Capacity Heatmap” section to make these load insights visible.

Engagement Opportunity Ranking & Follow-up Drafting: The Engagement Crew keeps an eye on all prospects and clients to ensure timely follow-ups. It continuously scans for signals that someone is “touch-ready” – meaning a prompt outreach could be fruitful. Signals include CRM activity (e.g. a deal stalled with no updates for 7 days), inbound communications (e.g. a prospect hasn’t replied to an email for 3 days or conversely they just clicked a link in your email), social/media mentions (the prospect’s company raised funding or the contact viewed your LinkedIn post), and calendar cues (a week before a scheduled meeting, perhaps send materials). These inputs feed an AI model that ranks which contacts are the highest priority for engagement now. For each top candidate, the system generates a personalized draft message and a rationale. For example, “Draft email: Congratulate Jane on their Series B funding… – Why now: she opened our last newsletter and her company was in the news for a big launch.” The draft includes a recommended channel (perhaps an email vs a LinkedIn message) and is written in the user’s tone, based on past emails for consistency. The rationale always cites the evidence (e.g. “you saw this person did X, which suggests…”), and the suggestion is stored in app.engagement_opportunities with fields for the message content, suggested send method, and reason. These appear in the Robbie Inbox under a “Touch-Ready” section for the user to review. The user can one-click approve the draft, edit it, or skip it. Guardrails ensure no spammy behavior – the system checks the contact hasn’t exceeded touch frequency limits and hasn’t shown recent negative sentiment. (For example, if the contact got 3 emails already this week or recently responded angrily, the suggestion will be held back by the Guardrails Crew.) By automating follow-up nudges in a thoughtful way, this feature prevents deals from going cold while saving the user time on writing routine check-in emails.

Meeting Transcript Mining & Task Creation: After each significant meeting or call, the Transcript Crew goes to work analyzing the conversation (using the recording or transcript, e.g. pulled from Fireflies). The AI looks for key takeaways: Next Steps, Action Items, Decisions, and Important Insights. These are extracted with associated confidence levels and saved as “sticky notes” in the system. For instance, if a client says “We’ll send the contract by Friday” or the user says “I will prepare a demo for you,” the system captures that as a next-step task. Extracted items are presented to the user for validation in the meeting notes UI – e.g. on the Notes board, Robbie might post an 🟩 Action note: “Prepare demo for Client X by Friday – (from meeting on 9/10)”. The user can confirm or edit these. Once approved, Robbie can then create tasks in the task management system (or in Robbie’s own task list) automatically. This implements the “automatic task creation from team emails/meetings with acceptance flow” – no task is added without user review, but the user doesn’t have to manually transcribe action items; Robbie does the initial lift. Over time, a knowledge base of decisions and promises accumulates (in app.transcript_insights and app.notes) which Robbie can reference later (say, to remind you “Today is Friday, you promised a demo to Client X”). The Transcript Crew essentially ensures follow-through on meetings: every promise or question is logged so nothing slips through the cracks. The AI model for this uses keyphrase detection and semantic analysis to identify commitments or questions, and there’s a feedback loop – if the user corrects or adds an item, Robbie learns from that to better parse future meetings.

Deal Risk Analysis & Proposal Assistance: For deals in the pipeline, especially in late stages, Robbie provides AI help in sizing the deal and enforcing approval policies. The Deal Analyzer Crew looks at opportunities reaching a quote/proposal stage or any time a sales rep seeks to apply a significant discount. It pulls in context – similar past deals, the prospect’s profile, product pricing benchmarks – and suggests an optimal price or discount to maximize win probability without giving away too much. The suggestion (e.g. “Propose $50,000 with a 5% discount, confidence 0.8”) is saved in app.deal_size_proposals along with the rationale (“based on similar clients and strong positive engagement from this lead”). If a rep tries to apply a larger discount or change a deal value beyond allowed thresholds, the Guardrails/Approvals workflow kicks in. Company policy might say any discount >30% or deal change >20% requires management approval. Robbie will intercept the change, notating that approval is required, and route an approval request to the appropriate manager (e.g. via Slack or email: “Approval needed for 40% discount on Deal XYZ”). Approvers get a one-click interface to approve or deny, and their decision is logged in an app.approvals table. Until approved, the deal in CRM is locked from that change. If approved, Robbie updates the CRM (HubSpot) with the new pricing and notes who approved it. If rejected, Robbie can even prompt the Deal Analyzer to suggest an alternative within allowed bounds (e.g. “Manager said max 10% – here’s a recalculated proposal at 10%”). This workflow ensures large concessions are controlled and provides data-driven suggestions to speed up quote generation. It also builds a history of what discounts tend to be approved or rejected, refining future recommendations. In short, Robbie helps structure deals for success while protecting margins and enforcing policy.

Communication Guardrails & Compliance: Throughout all the above processes, the Guardrails Crew is ever-present to enforce communication rules and maintain a healthy relationship with contacts. These guardrails implement policies such as: no contact gets more than 3 outreach touches per week and at least 48 hours apart; if a contact gives a strong negative signal (e.g. an email with very negative sentiment score), they should be placed in a 14-day cooling-off period before any further outreach; and diversify channels (don’t spam via the same medium repeatedly). These rules are configurable in tables like app.comms_policies and app.comms_fatigue which track contact-specific fatigue scores. Robbie will automatically suppress or delay actions that would violate these limits – e.g. if an Engagement suggestion is generated but the contact has already hit their quota of emails, the suggestion is held back. Another aspect is permission and role checks: only the owner of a deal can edit its stages or notes unless they delegate access. Robbie’s crews respect these restrictions, ensuring, for example, that an automated workflow doesn’t reassign someone else’s deal without proper conditions. Compliance with opt-out and unsubscribe is also crucial (e.g. if a contact’s unsubscribed=true, no email will be sent). The Guardrails Crew thus acts as the safety net, gating AI actions so that all automated outputs remain within acceptable and ethical bounds. It logs any blocked actions or policy triggers so that users can see “violation prevented: contact was in cooldown” in a Guardrails Console UI. These guardrails make the user comfortable trusting Robbie with more autonomy, knowing it won’t overstep preset limits.

All these workflows are orchestrated by the central n8n MCP and are instrumented for observability. Every time a workflow runs, it logs an entry (in app.mcp_calls) with what was done, how long it took, and whether it succeeded. This makes it easier to debug or roll back any unintended changes. There are also cost and usage tracking mechanisms – for instance, ai.model_usage logs each call to an AI model (GPT or others) with token counts and costs, so the team can monitor spending and estimate “time saved vs. cost.” Over time, Robbie’s decision engine will continue learning: by monitoring outcomes (did the AI-suggested email get a reply? did the auto-routed lead convert faster?), it will refine its suggestions and prioritization models. This closed-loop learning is the “adaptive” part of the reasoning engine, ensuring that automation adds more value over time as it observes what works and what doesn’t.

Productivity & Smart Scheduling Features

In addition to sales-oriented workflows, Robbie V3 serves as a personal productivity assistant to manage the user’s tasks, schedule, and communications more intelligently.

Unified Task Management: Robbie integrates with task systems (e.g. ClickUp, or it can use its own internal task list) to provide a central task view and AI-powered task management. It will aggregate tasks from various sources – action items generated by the Transcript Crew, to-dos captured by the user, tasks from emails (e.g. if someone emailed asking for something due next week, Robbie can create a task for the user) – into one list. The assistant can then apply “full tasklist intelligence”: it automatically prioritizes tasks, renames them for clarity, and even suggests pruning tasks that seem obsolete. For example, if a task has been open for 60 days with no activity and context suggests it’s no longer relevant, Robbie might flag it for removal. Prioritization is done by considering due dates (from calendar), importance (e.g. tasks from key clients or flagged as urgent), and dependencies (if certain tasks unlock others). Robbie will be able to reorder the task list each day and highlight the top N tasks to focus on. It can also group related tasks or label them (it might tag tasks with emojis or colors like 🔴 for high priority, or 🕓 for tasks waiting on someone else). Whenever Robbie sends the daily summary (described below), it will include a section on open tasks with statuses and suggestions (like “🟢 3 tasks due tomorrow, all on track” or “🔴 1 task overdue – consider rescheduling or escalating”). By having tasks in the same interface as emails and notes, the user can seamlessly update or complete them, and Robbie can mark things as done based on actual events (e.g. if an email reply indicates a task was completed, Robbie can auto-complete that task). This intelligent task management is facilitated by integration hooks (e.g. n8n workflows like clickup.tasks can sync tasks bi-directionally). It ensures nothing falls through and the user always knows what their true priorities are.

Calendar Optimization & Scheduling Assistance: Robbie takes an active role in managing the user’s calendar to protect focus time and optimize meeting schedules. It syncs with Google Calendar to see all events and free/busy times. The assistant will automatically schedule “deep work” blocks by analyzing the calendar and finding open periods where it can block time for focused work. For example, if it notices the user has no meetings from 2-4pm on Wednesday, it might schedule a block titled "Focus Time" (perhaps marked with an emoji like 🔵 or 🔕) to discourage other meetings and to remind the user to use that time for high-priority work. These focus blocks will be colored distinctly (e.g. grey or blue) and could carry an emoji indicator like ⚡ (if it’s meant for high-energy work) or 🧘 (if it’s meant as a quiet time), aligned with the energy slider described later. Robbie can also color-code meetings based on certain attributes: for instance, internal meetings vs client calls vs personal time might each have a different color or icon, giving a visual “heat map” of the calendar. The concept of meeting health indicators will be introduced – Robbie will evaluate meetings on factors like: does the meeting have an agenda? How long is it (and is that length appropriate)? Who is invited (too many people?), and historically, did similar meetings result in outcomes? It can then tag events with an icon or score. For example, a meeting with no agenda and 10 attendees might get a ⚠️ indicating a likely low-productivity meeting, whereas a one-on-one with a clear purpose might get a ✅. After meetings, Robbie (with integration to Fireflies) can even assess how much each attendee spoke, whether decisions were made, etc., and use that to refine the “meeting quality” metric. These meeting analytics help the user identify which meetings to cut or improve.

Robbie’s scheduling intelligence is also mood-aware and habit-aware. The system keeps a simple mood model for the user in app.robbie_mood_state that can be updated by signals like sentiment in emails or self-reported status. If Robbie detects the user’s mood or energy is low (e.g. many negative sentiments in communications or user feedback), it might adjust the schedule to be lighter or insert a break (for instance, suggest “how about a short walk?” or schedule a 15-min mindfulness break). Conversely, if the user is in a high-energy state, Robbie might cluster more challenging tasks in that period. Habit-aware scheduling means Robbie learns the user’s personal routines and preferences – e.g. if the user usually goes to the gym on Tuesday mornings or picks up kids at 5pm, the assistant will avoid those times or automatically block them. It can also help encourage positive habits: for example, if the user wanted to start doing weekly team coffee chats or evening walks, Robbie can reserve those slots and remind the user. We see parallels in tools like Reclaim.ai which focus on habit scheduling and buffer times, and Robbie will integrate similar ideas: automatically adding buffer time between back-to-back meetings (to recover and prepare) and allocating time for regular activities (like daily email cleanup, or a weekly project review). The user can configure preferences, such as not allowing meetings on Friday afternoons (Robbie will then mark that time as “Deep Work” or personal time) or always keeping Monday mornings free for planning. Over time, by analyzing what scheduling patterns lead to higher productivity (drawing from best practices), Robbie will fine-tune the calendar to align with the user’s optimal work style.

When scheduling new meetings, Robbie can act as an AI scheduler: if a prospect wants to meet next week, the assistant can automatically propose a slot that works for both parties, considering time zones and prior commitments. It’s aware of things like not double-booking, avoiding too many meetings in one day, and preferring times the user tends to be most receptive (for example, if the user does their best deep work in mornings, Robbie might push external meetings to afternoons). It also considers team scheduling in Phase 2 – ensuring key team meetings don’t conflict with individual deep work blocks and perhaps rotating meeting times for fairness across time zones. Essentially, Robbie becomes a smart calendar concierge that optimizes the user’s time allocation: maximizing focus, ensuring rest, and aligning with the user’s life rhythms.

Email & Slack Triage and Cleanup: Robbie’s Inbox interface aggregates emails, Slack messages, and other incoming communications into one prioritized view. It labels truly urgent items (using an urgency score, e.g. based on sender importance and content, where ≥90 appears under an “URGENT” section) and separates AI-suggested outgoing drafts in a “Touch-Ready” section. The user can take actions like reply, snooze, or assign a follow-up directly from this interface. A unique feature is smart cleanup after acknowledgment: when the user has addressed an item, Robbie can automatically tidy up. For example, if the user clicked “Reply” on an email via Robbie, after sending, Robbie can archive that email from the Gmail inbox (so the user doesn’t have to see it again). If a Slack message was turned into a task or marked as “read” by the user in Robbie’s interface, the assistant can automatically mark it read in Slack or move it out of the priority list. Essentially, once the user acknowledges or takes an action on a conversation, Robbie “clears” it from the immediate attention list, either by marking it done or scheduling it to resurface later if needed. Snooze is supported – e.g. “remind me about this Tuesday” will temporarily hide an email and bring it back to the top on Tuesday. The Inbox also provides a visualization of email load by day (a bar chart for the week) to help the user plan when to catch up. These features keep the inbox zero-ish without things falling away unnoticed. The user can batch process items too – for instance, “Mark all as read” or accept all draft suggestions at once, etc.. This smart triage means by end of day, ideally, the user’s communications are either dealt with or scheduled, and nothing lingers without a decision.

Daily and Weekly Summaries: Robbie will deliver a Daily Digest every weekday at 5pm (time configurable) via email (and Slack DM if integrated). This personal summary will include: what tasks were completed today, what’s upcoming tomorrow, any important emails or messages that might have been missed or that were handled by Robbie, and an estimate of time saved by Robbie’s automations. For example, it might say “Drafted 5 follow-up emails and logged 3 tasks from meetings – estimated 40 minutes saved.” It also might highlight quick wins, like “You gained 2 hours of focus time by deferring low-priority meetings.” The time-saved metric is calculated from the number of AI actions (like drafting an email might count as 5 minutes saved, scheduling a meeting 10 minutes, etc.) and is meant to give the user tangible feedback on Robbie’s value. The digest will also update on any team metrics if in team mode (e.g. “Team closed 2 deals today, pipeline health is good”). This concept is similar to the Weekly Digest that Robbie can produce for team leadership: a comprehensive report of pipeline health, team workload, top alerts, and so on. In fact, Robbie’s architecture already has a weekly digest generator (app.v_weekly_digest materialized view) with sections like Top Alerts, My Week, Pipeline Health, Team Focus, Capacity Heatmap, Engagement Queue, and Blockers. That weekly report is delivered via email and also pinned in the app with source links for drill-down. The Daily Digest we implement will be a pared-down, daily-focused variant for personal productivity, whereas the Weekly might be more about sales pipeline and team (Phase 2 feature). Both serve to keep the user informed proactively, without having to query the system.

In addition, Robbie can send real-time alerts for critical events (for example, if a high-priority email from the CEO arrives, Robbie might push a mobile notification or Slack alert immediately). But the general philosophy is to batch information into the digest to avoid constant interruptions – aligning with the idea of reducing notification noise and only surfacing urgent exceptions immediately.

User Interface & Controls

Robbie’s user interface is designed to be intuitive and information-dense, combining conversational AI elements with dashboard-style widgets. The main UI surfaces include:

Chat Interface: A chatbox where the user can interact with Robbie in natural language, much like ChatGPT. The conversation view streams Robbie’s responses token-by-token, and supports Markdown formatting (so Robbie’s answers can include lists, code blocks, etc.). What sets it apart are the Founder Power Toggles – special controls for power users that appear at the top of the chat pane. For example, there is a “>_ Terminal” toggle that, when activated, allows Robbie to act with higher privileges (the assistant can execute certain backend commands or retrieve data directly, useful for advanced operations or debugging). There’s also a “🌐 Web” toggle for web takeover, which could let Robbie browse an internal knowledge base or the internet for answers (if enabled). A “🔍 Search” icon can cue Robbie to perform a deep search in the connected data for supporting evidence. These toggles essentially give the user control over Robbie’s behavior – from a friendly advisor mode to a more technical mode. The chat interface also supports quick action buttons that Robbie may provide in responses. For example, if the user asks a question (“Any pipeline risks?”), Robbie might answer and show action chips like “[Open Stalled Deals]” or “[Send Nudges]” right below the message. The user can click those to execute the suggested actions immediately. There’s also a “Show Why” option that opens a side panel with the evidence behind Robbie’s answer (e.g. which data points or analytics led to that conclusion). This increases transparency. The chat input box allows slash commands for common actions (like "/schedule meeting with Alice") and attachments if needed. Essentially, the chat is the command center for conversing with Robbie, with UI affordances that merge chat and GUI for efficiency.

Inbox: A unified inbox panel that combines Email and Slack (and other message sources) for triage. It provides filter tabs to view All vs just Email vs just Slack, etc., and separates messages into priority categories. “Urgent” shows high-priority unread messages, each with suggested one-click actions (e.g. “[Reply]”, “[Mark Incident]”, “[Alert Team]” for an email about an outage). “Touch-Ready” shows AI-suggested outreach opportunities (with the draft message preview and options like “[Open Draft]”, “[Skip]”, “[Not relevant]”). The inbox also displays visual email stats for the past 7 days (perhaps a mini bar chart of incoming messages per day). From here, the user can quickly clear their communications – when an item is handled, it disappears or goes to a “Done” state. Snoozing and batch actions are available from this interface. The design is to prevent the user from needing to context-switch between an email app and Slack and others; Robbie brings them all together with AI prioritization on top.

Notes (Sticky Wall): A notes dashboard that appears as a pinboard of “sticky notes”. These notes are the insights and to-dos that Robbie (or the user) has logged – e.g. key insights (🟡), action items (🟩), objections or concerns (🩷) from conversations. They are color-coded and labeled by type. The UI allows filtering notes by category and sorting (newest, by contact, etc.). Notes look like actual sticky notes on a board, possibly with a handwriting-esque font for a natural feel. The user can drag them around or cluster them. There’s a feature to automatically cluster notes by theme, which could rearrange them into groups (e.g. all notes related to a specific project together). Older notes might “fade” or archive visually (e.g. curling or semi-transparent) to indicate staleness. The Sticky Wall is basically the place to find any important information Robbie has surfaced – from meeting takeaways to strategy insights – in a persistent form. Users can add manual notes here as well (like a scratchpad).

Pipeline & Deals: A sales pipeline view that shows deals in different stages and their health. It can be presented as a kanban or stage-wise list. Each stage (Awareness, Engage, Qualify, etc.) has a column with deals, possibly aggregated by risk level (green = good, yellow = watch, red = risk). The UI might display counts of deals in each category with colored indicators (e.g. “Qualify — 2 deals at risk (red)”). Clicking on a stage cell could list the specific deals and quick actions for each (open CRM record, send nudge, escalate to exec). There’s also an FY Goal panel showing progress toward the sales goal, probability to hit it, and Robbie’s tip like “+2 nudges → increase win probability to 81%”. This Pipeline screen helps users and teams manage sales opportunities at a glance, highlighting where Robbie suggests attention (like stalled deals or big deals nearing close). Owner avatars might show who owns what, and velocity arrows might indicate if a deal is moving fast or slow.

Marketing Dashboard: If the user/team uses marketing campaigns, Robbie provides a dashboard for Marketing Intelligence. This might include a Budget Control section showing ad spend vs budget in real-time, with controls to adjust (e.g. “[Apply]” button to a suggested reallocation). There’s an Attribution summary showing which campaigns or content are driving ROI (e.g. “Food Guide Series ROI 1391%”). Channel breakdowns might show CAC or conversion by channel (LinkedIn vs referral, etc.). Importantly, there’s a Deliverability/Spam safety section with a mode slider from conservative to aggressive. This is the “Genghis ↔ Gandhi” slider, conceptually – it lets the user tune how aggressive the outreach strategy should be. In the UI it’s labeled perhaps as “Mode: Conservative ● Balanced ● Aggressive” with a fine-tune scale (0 to 100). Sliding it might change how many emails go out, how risk-tolerant the system is with spam thresholds, etc. This way, the user has a macro control over Robbie’s outreach personality – from a gentle Gandhi approach (minimal touches, very cautious) to a bold Genghis approach (max allowed touches, push harder for responses). The balanced middle is the default. Robbie will give feedback like “+10 intensity for 2 weeks → +7% replies, <1% risk” as shown in the UI, so the user understands the trade-off. The marketing screen also includes quick insights from Robbie (“Robbie says: ...”) similar to the pipeline.

Home (Executive Snapshot): A home dashboard that aggregates key info for quick review. It might show metrics like current pipeline total vs goal, number of meetings this week, number of open tasks, today’s schedule highlight, and marketing spend at a glance. Below that, an “Attention” list highlights important items requiring user approval or decision (e.g. “Approve 35% discount for Deal XYZ [Approve] [Decline]”, “Rebalance LinkedIn budget +$250 [Open Spend Control]”, “Nudge 2 stalled deals [Send Nudges]”). And perhaps a quick insight of the day (“Robbie says: Referral ROI is 5× this month; shift +$500/day to that channel”). The Home is like a daily command center for the user – one screen to see everything that needs their input or awareness. It may also show team status (who’s online, any outages or critical alerts in systems) and contextual info like weather if relevant to scheduling a golf meeting, etc..

Across the UI, consistency and speed are emphasized. A command palette (Ctrl/Cmd+K) is available to quickly jump to any action or page, powered by Robbie’s own MCP actions. Keyboard shortcuts exist for navigation and for common actions (like “N” for new note, “R” for reply when an item is selected). The UI also indicates Robbie’s “mood” or tone via the avatar in the header – the avatar might change expression or color based on the assistant’s current persona/mode (if the Genghis/Gandhi slider is set to Aggressive, maybe Robbie’s avatar looks intense, vs calm for conservative). These are subtle cues to keep the user informed of how the AI is tuned.

Lastly, in Settings/Admin screens, the user can manage integrations (API keys, OAuth connections), adjust guardrail policies (like turn on/off certain limits), and toggle beta features. This includes the fun sliders like the “Genghis 🠒 Gandhi” aggressiveness slider for outreach and the “Cocktail 🠒 Lightning” energy slider for scheduling intensity. The Cocktail vs. Lightning slider lets the user indicate their current work style preference – Cocktail meaning a relaxed pace with downtime (Robbie will then schedule more breaks, and not fill the calendar completely) versus Lightning meaning a fast-paced day (Robbie will pack the schedule tightly with tasks and meetings if possible, and push for more output). By adjusting this, the user can essentially tell Robbie “today, take it easy” or “today, load me up”. This is a novel UX element to make the AI more attuned to user’s day-to-day preference, almost like a mood ring for productivity. Combined with the mood detection, Robbie can also make suggestions (“You seem low-energy, maybe switch to Cocktail mode?” or “You have a lot to do, consider Lightning mode.”). These frontend features ensure the user always feels in control of Robbie’s level of proactiveness and tone.

Implementation & Deployment Details

The Robbie V3 system will be delivered as a containerized or scripted deployment on the provided Elestio VM. The deployment checklist includes setting up all services (Postgres DB, Redis, Node API, React front-end, n8n, Ollama, Nginx) via infrastructure-as-code (the provided Bash script covers most of this). We will use a GitHub repository for all Robbie code (with a monorepo or split repos for front-end, backend, etc., as appropriate), and a CI/CD pipeline such that pushing to main can auto-deploy to a staging environment, and a manual approval to deploy to production on the Elestio VM. Environment variables for secrets will be stored in the VM (and not in Git). We’ll also set up monitoring and logging: e.g. integrate with a service like Grafana/Prometheus or use Elestio’s monitoring to track CPU/memory, and set up alerts if the app goes down. Daily database backups will be configured (snapshot or pg_dump) and important data like the vector index can be restored from backup if needed.

Testing & QA: The implementation will include comprehensive tests for each integration (using sandbox accounts or sample data) to ensure that, for example, Gmail API tokens are working, Slack bot can post/read, HubSpot sync is correct, etc. We’ll also test the CrewAI workflows with various scenarios (lead assignment when someone is at capacity, follow-up suggestions under different conditions, transcript parsing with sample transcripts, approval flows for discounts, scheduling adjustments on calendar changes, etc.). Each major feature will have a runbook or test case list to verify it in a staging environment before going live.

The system will launch initially with the personal scope configuration (one user org, personal data). Multi-user support is built-in but we will likely hide team-related UI until Phase 2. Feature flags will guard things like Slack Q&A (not enabled until ready). By the end of the project, Robbie V3 should be running smoothly on the VM with all key features operational for the initial user, and the groundwork laid for onboarding additional users/teams securely.

Delivery Checklist ✅

Upon completion of Robbie V3 implementation, the following key features and components will be delivered and functioning. (This serves as a checklist for final acceptance testing.):

 Secure Authentication & User Accounts: Email/password login with Argon2id hashing and 3-strike lockout, email verification, session management, and OAuth integration for Google/Slack/etc. (with audit logging of auth events).

 Core Data Platform: PostgreSQL database (with auth, app, ai schemas) set up as single source of truth, including CRM tables (contacts, companies, deals), communications (emails, interactions), scheduling (calendar events), and vector memory index (ai.conversation_index for embeddings). Redis in place for caching and queues.

 Integrations – Gmail & Calendar: OAuth connection to Gmail enabling read of emails and send capability. Historical email import (all past emails pulled into messages table) and ongoing sync (new emails appear in Robbie within minutes). Calendar OAuth enabling read/write of events, with import of past calendar events and continuous sync of new events.

 Integrations – Slack & Messaging: Slack bot connected and invited to relevant channels/DMs. Ability to read incoming Slack messages and post as the assistant bot. Historical Slack channel history import for context (where available via Slack API) and ongoing event subscription.

 Integrations – HubSpot CRM: API integration with HubSpot to pull Contacts, Companies, Deals and keep them in sync. New or updated deals in HubSpot trigger Robbie workflows (like assignment). Ability to push updates back (e.g. if Robbie assigns a new owner or creates a contact, it updates HubSpot).

 Integrations – Phone & Meetings: OpenPhone integration (API or webhook) to log calls and SMS (call summaries or transcripts if available). Fireflies.ai integration working – meeting transcripts automatically retrieved after meetings and fed to Robbie’s transcript mining. (If Fireflies not available, an alternative transcript source or dummy data will be used for testing.)

 Master Control Program (n8n) Automations: n8n is deployed and running the suite of Robbie workflows. This includes database utility workflows, CRM sync workflows, communication actions (Gmail send, Slack post), calendar actions, and AI utilities (embedding creation, transcript analysis). Each workflow has been tested for idempotency and error handling (retry logic on failures).

 AI Service Processes: All major automation services are implemented and active behind the scenes:

Lead Assignment & Routing (A/B/C assignment policy with capacity check).

Engagement Opportunity detection & follow-up drafting (with suggestions appearing in the Inbox).

Meeting Transcript mining for notes and tasks (with output to Notes board and task system).

Deal size proposal & discount approval workflow (recommendation saved and approval requests generated if thresholds exceeded).

Guardrails enforcement on communication frequency, sentiment cool-offs, and permission checks (tested by attempting edge-case sends and ensuring they are blocked appropriately).

 AI Memory & Knowledge Base: The vector database is operational – content from emails, Slack, and notes is being embedded (1536-d embeddings) and stored in ai.conversation_index. Robbie’s prompt builder is successfully retrieving relevant context via semantic search when answering queries. The summarization mechanism is working (e.g., long Slack threads get summarized after a length threshold, and the summary stored as a note). We will verify that asking a question about past discussions yields an answer that references older context (proving the memory retrieval works).

 Frontend Web App: React application deployed and accessible via the custom domain (with SSL). All UI panels are implemented according to spec:

Chat interface with streaming responses and action buttons.

Unified Inbox with filters, Urgent and Touch-Ready sections, and working actions (reply, snooze, etc.).

Notes Sticky Wall showing categorized notes (insight/action/objection).

Pipeline view with deals by stage, risk coloring, and quick actions on deals.

Marketing dashboard with budget status and deliverability mode slider.

Home snapshot with key metrics and “Attention” items with action buttons.
The UI should be responsive (usable on a laptop screen primarily, but check key views on mobile/tablet). No major bugs in interaction (we test clicking all buttons, toggling filters, etc.). Real-time updates via WebSocket confirmed (e.g. if a new email arrives, it appears in the Inbox without refresh).

 Personalization Controls: The Genghis–Gandhi aggressiveness slider is present (in Settings or Marketing panel) to control outreach aggressiveness, and it influences the Engagement suggestions (tested by toggling to “Aggressive” and seeing more frequent suggestions vs “Conservative” fewer suggestions). The Cocktail–Lightning energy slider is present (likely in Scheduling settings or the Home panel) to control scheduling density, and it influences calendar suggestions (tested by switching to Lightning and seeing Robbie schedule more focus blocks/pack meetings vs Cocktail where it leaves more breaks).

 Daily Digest & Notifications: The 5pm Daily Digest email (and Slack message) is generated and sent to the user. Verify it includes a summary of tasks done, pending tasks, any key events of the day, and a time-saved estimate. Also verify the Weekly Digest (if applicable in team phase) can be generated from the system’s data. Ensure notifications/alerts are working – e.g., test an urgent condition (like an email from a VIP) and see if Robbie flags or alerts it appropriately.

 Email/Slack Cleanup Automation: Confirm that when the user handles an item via Robbie (e.g. sends a reply from the Robbie UI, or marks a task done), the system marks the original source as handled (the email gets archived or marked read, the Slack message marked read or removed from queue). Test snooze on an email and ensure it returns at the set time and not before.

 Task Management & Calendar Blocks: If using an external task system (ClickUp), verify tasks are syncing (creation, completion). Confirm Robbie is adding “Focus Time” blocks to calendar (e.g. if a free morning exists) and not colliding with events. Test that an event without an agenda gets a warning icon in the UI (meeting health indicator) and that an event marked as “Do Not Schedule” is respected by the scheduling logic.

 Performance & Load: Under a realistic load (e.g. a mailbox of several thousand emails, hundreds of contacts, dozens of active deals), the system performs within acceptable range (pages load within a couple seconds, chat responses in a timely manner depending on model). No memory leaks or crashes under continuous operation.

 Deployment & Security Checks: The app is running on the designated VM behind Nginx with SSL. Only ports 443 (HTTPS) and 2222 (SSH) are open to public, as well as any required webhook endpoints (which are behind authentication as needed). Verify one cannot access the database or n8n directly without proper credentials. All environment secrets are correctly in place (we can rotate a token in /etc/app/env and see it reflected). Backups are running (simulate a backup restore in staging). Logging and monitoring are capturing system health (e.g. check that we have logs for API, n8n, etc., and that Fail2Ban is active to block intrusion attempts).

Each item above will be verified with the client/user to ensure the Robbie V3 assistant system meets the expected scope and functionality. With all boxes checked, Robbie V3 will be live as a personal AI copilot ready to expand into team use – delivering daily value by saving time, providing insights, and keeping the user’s work organized.
